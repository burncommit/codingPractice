<img width="80%" src="https://user-images.githubusercontent.com/109085338/236971787-d5dc7c38-51c3-4743-b04c-f45d987464e3.png"/>
<img width="80%" src="https://user-images.githubusercontent.com/109085338/236971806-68df92ea-5e26-4be1-85ed-dbe7589f6a17.png"/>
---------------------------------------------------------------------------------------------------------------------------

```
 class Solution {
    public String[] solution(String[] players, String[] callings) {
       String[] answer = players.clone();
         for(int j = 0; j < callings.length; j++){
            for(int i = 1; i < players.length; i++){
                if(callings[j].equals(players[i])){
        answer [i] = players[i-1];
        answer [i-1] = players[i];
                    players[i] = answer[i];
                    players[i-1] = answer[i-1];
                    }
            }
        }
        return answer;
    }
}

        처음에는 2중포문으로 매치됐을때만 순위가 바뀌도록 로직을 짰었음
        답은 나오지만 시간초과로 실패가 나왔다.
```

```
import java.util.*;

class Solution {
    public String[] solution(String[] players, String[] callings) {
 
        for(int i = 0; i < callings.length; i++){
            int num = Arrays.asList(players).indexOf(callings[i]); 
            String a = players[num];
            String b = players[num-1];
            players[num] = b;
            players[num-1] = a;
        }
       
        String[] answer = players.clone();
        return answer;
        
    }
}
        2중포문을 줄이기 위해 callings와 매치되는 값을가진 players의 인덱스를 찾기위해
        indexOf를 씀 하지만 찾기 위한 방식이 같은지? 약간의 시간만 줄어들고 마찬가지로 시간초과로 실패함
```
